<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PCM音频数据</title>
      <link href="2021/04/02/PCM%E9%9F%B3%E9%A2%91%E6%95%B0%E6%8D%AE/"/>
      <url>2021/04/02/PCM%E9%9F%B3%E9%A2%91%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是PCM？"><a href="#1-什么是PCM？" class="headerlink" title="1. 什么是PCM？"></a>1. 什么是PCM？</h2><p>PCM(Pulse Code Modulation，脉冲编码调制)音频数据是未经压缩的音频采样数据裸流，它是由模拟信号经过采样、量化、编码转换成的标准数字音频数据。</p><p>描述PCM数据的6个参数：</p><p>1.Sample Rate : 采样频率。8kHz(电话)、44.1kHz(CD)、48kHz(DVD)。<br>2.Sample Size : 量化位数。通常该值为16-bit。<br>3.Number of Channels : 通道个数。常见的音频有立体声(stereo)和单声道(mono)两种类型，立体声包含左声道和右声道。另外还有环绕立体声等其它不太常用的类型。<br>4.Sign : 表示样本数据是否是有符号位，比如用一字节表示的样本数据，有符号的话表示范围为-128 ~ 127，无符号是0 ~ 255。<br>5.Byte Ordering : 字节序。字节序是little-endian还是big-endian。通常均为little-endian。字节序说明见第4节。<br>6.Integer Or Floating Point : 整形或浮点型。大多数格式的PCM样本数据使用整形表示，而在一些对精度要求高的应用方面，使用浮点类型表示PCM样本数据。</p><p>推荐的PCM数据播放工具：</p><p>ffplay, 使用示例如下：</p><pre class=" language-bash"><code class="language-bash">//播放格式为f32le，单声道，采样频率48000Hz的PCM数据$ ffplay -f f32le -ac 1 -ar 48000 pcm_audio</code></pre><p>Audacity：一款免费开源的跨平台音频处理软件。<br>Adobe Auditon。导入原始数据，打开的时候需要选择采样率、格式和字节序。</p><h2 id="2-PCM数据格式"><a href="#2-PCM数据格式" class="headerlink" title="2. PCM数据格式"></a>2. PCM数据格式</h2><p>如果是单声道的音频文件，采样数据按时间的先后顺序依次存入（有的时候也会采用LRLRLR方式存储，只是另一个声道的数据为0），如果是双声道的话就按照LRLRLR的方式存储，存储的时候与字节序有关。big-endian模式如下图所示：</p><p><img src="/2021/04/02/PCM%E9%9F%B3%E9%A2%91%E6%95%B0%E6%8D%AE/PCM.png" alt="PCM"></p><h2 id="3-FFmpeg支持的PCM数据格式"><a href="#3-FFmpeg支持的PCM数据格式" class="headerlink" title="3. FFmpeg支持的PCM数据格式"></a>3. FFmpeg支持的PCM数据格式</h2><p>使用ffmpeg -formats命令，获取ffmpeg支持的音视频格式，其中我们可以找到支持的PCM格式。</p><pre class=" language-bash"><code class="language-bash"> DE alaw            PCM A-law　DE f32be           PCM 32-bit floating-point big-endian　DE f32le           PCM 32-bit floating-point little-endian　DE f64be           PCM 64-bit floating-point big-endian　DE f64le           PCM 64-bit floating-point little-endian　DE mulaw           PCM mu-law　DE s16be           PCM signed 16-bit big-endian　DE s16le           PCM signed 16-bit little-endian　DE s24be           PCM signed 24-bit big-endian　DE s24le           PCM signed 24-bit little-endian　DE s32be           PCM signed 32-bit big-endian　DE s32le           PCM signed 32-bit little-endian　DE s8              PCM signed 8-bit　DE u16be           PCM unsigned 16-bit big-endian　DE u16le           PCM unsigned 16-bit little-endian　DE u24be           PCM unsigned 24-bit big-endian　DE u24le           PCM unsigned 24-bit little-endian　DE u32be           PCM unsigned 32-bit big-endian　DE u32le           PCM unsigned 32-bit little-endian　DE u8              PCM unsigned 8-bit</code></pre><p>s是有符号，u是无符号，f是浮点数。<br>be是大端，le是小端。</p><h2 id="4-FFmpeg中Packed和Planar的PCM数据区别"><a href="#4-FFmpeg中Packed和Planar的PCM数据区别" class="headerlink" title="4. FFmpeg中Packed和Planar的PCM数据区别"></a>4. FFmpeg中Packed和Planar的PCM数据区别</h2><p>FFmpeg中音视频数据基本上都有Packed和Planar两种存储方式，对于双声道音频来说，Packed方式为两个声道的数据交错存储；Planar方式为两个声道分开存储。假设一个L/R为一个采样点，数据存储的方式如下所示：</p><p>Packed: L R L R L R L R<br>Planar: L L L L R R R R<br>FFmpeg音频解码后的数据是存放在AVFrame结构中的。</p><p>Packed格式，frame.data[0]或frame.extended_data[0]包含所有的音频数据中。<br>Planar格式，frame.data[i]或者frame.extended_data[i]表示第i个声道的数据（假设声道0是第一个）, AVFrame.data数组大小固定为8，如果声道数超过8，需要从frame.extended_data获取声道数据。<br>下面为FFmpeg内部存储音频使用的采样格式，所有的Planar格式后面都有字母P标识。</p><pre class=" language-bash"><code class="language-bash">enum AVSampleFormat <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>    AV_SAMPLE_FMT_NONE <span class="token operator">=</span> -1,    AV_SAMPLE_FMT_U8,          ///<span class="token operator">&lt;</span> unsigned 8 bits    AV_SAMPLE_FMT_S16,         ///<span class="token operator">&lt;</span> signed 16 bits    AV_SAMPLE_FMT_S32,         ///<span class="token operator">&lt;</span> signed 32 bits    AV_SAMPLE_FMT_FLT,         ///<span class="token operator">&lt;</span> float    AV_SAMPLE_FMT_DBL,         ///<span class="token operator">&lt;</span> double    AV_SAMPLE_FMT_U8P,         ///<span class="token operator">&lt;</span> unsigned 8 bits, planar    AV_SAMPLE_FMT_S16P,        ///<span class="token operator">&lt;</span> signed 16 bits, planar    AV_SAMPLE_FMT_S32P,        ///<span class="token operator">&lt;</span> signed 32 bits, planar    AV_SAMPLE_FMT_FLTP,        ///<span class="token operator">&lt;</span> float, planar    AV_SAMPLE_FMT_DBLP,        ///<span class="token operator">&lt;</span> double, planar    AV_SAMPLE_FMT_S64,         ///<span class="token operator">&lt;</span> signed 64 bits    AV_SAMPLE_FMT_S64P,        ///<span class="token operator">&lt;</span> signed 64 bits, planar    AV_SAMPLE_FMT_NB           ///<span class="token operator">&lt;</span> Number of sample formats. DO NOT USE <span class="token keyword">if</span> linking dynamically<span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;;</span></code></pre><p>说明：</p><p>Planar模式是ffmpeg内部存储模式，我们实际使用的音频文件都是Packed模式的。<br>FFmpeg解码不同格式的音频输出的音频采样格式不是一样。测试发现，其中AAC解码输出的数据为浮点型的 AV_SAMPLE_FMT_FLTP 格式，MP3解码输出的数据为 AV_SAMPLE_FMT_S16P 格式（使用的mp3文件为16位深）。具体采样格式可以查看解码后的AVFrame中的format成员或解码器的AVCodecContext中的sample_fmt成员。<br>Planar或者Packed模式直接影响到保存文件时写文件的操作，操作数据的时候一定要先检测音频采样格式。</p><h2 id="5-字节序"><a href="#5-字节序" class="headerlink" title="5. 字节序"></a>5. 字节序</h2><p>谈到字节序的问题，必然牵涉到两大CPU派系。那就是Motorola的PowerPC系列CPU和Intel的x86系列CPU。PowerPC系列采用big endian方式存储数据，而x86系列则采用little endian方式存储数据。那么究竟什么是big endian，什么又是little endian？</p><p>big endian是指低地址存放最高有效字节（MSB，Most Significant Bit），而little endian则是低地址存放最低有效字节（LSB，Least Significant Bit）。</p><p>下面用图像加以说明。比如数字0x12345678在两种不同字节序CPU中的存储顺序如下所示：</p><p>Big Endian</p><p>低地址 高地址</p><p>—————————————————————————–&gt;</p><p>| 12 | 34 | 56 | 78 |</p><p>Little Endian</p><p>低地址 高地址</p><p>—————————————————————————–&gt;</p><p>| 78 | 56 | 34 | 12 |</p><p>所有网络协议都是采用big endian的方式来传输数据的。所以也把big endian方式称之为网络字节序。当两台采用不同字节序的主机通信时，在发送数据之前都必须经过字节序的转换成为网络字节序后再进行传输。</p><h2 id="6-PCM音频数据的处理"><a href="#6-PCM音频数据的处理" class="headerlink" title="6. PCM音频数据的处理"></a>6. PCM音频数据的处理</h2><p>分离双声道PCM音频数据左右声道的数据</p><p>按照双声道的LRLRLR的PCM音频数据可以通过将它们交叉的读出来的方式来分离左右声道的数据。</p><pre class=" language-bash"><code class="language-bash">int pcm_s16le_split<span class="token punctuation">(</span>const char* file, const char* out_lfile, const char* out_rfile<span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>     FILE *fp <span class="token operator">=</span> fopen<span class="token punctuation">(</span>file, <span class="token string">"rb+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> NULL<span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>         printf<span class="token punctuation">(</span><span class="token string">"open %s failed\n"</span>, file<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> -1<span class="token punctuation">;</span>     <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span>     FILE *fp1 <span class="token operator">=</span> fopen<span class="token punctuation">(</span>out_lfile, <span class="token string">"wb+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>fp1 <span class="token operator">==</span> NULL<span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>         printf<span class="token punctuation">(</span><span class="token string">"open %s failed\n"</span>, out_lfile<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> -1<span class="token punctuation">;</span>     <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span>     FILE *fp2 <span class="token operator">=</span> fopen<span class="token punctuation">(</span>out_rfile, <span class="token string">"wb+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>fp2 <span class="token operator">==</span> NULL<span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>         printf<span class="token punctuation">(</span><span class="token string">"open %s failed\n"</span>, out_rfile<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> -1<span class="token punctuation">;</span>     <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span>     char * sample <span class="token operator">=</span> <span class="token punctuation">(</span>char *<span class="token punctuation">)</span>malloc<span class="token punctuation">(</span>4<span class="token punctuation">)</span><span class="token punctuation">;</span>     while<span class="token punctuation">(</span><span class="token operator">!</span>feof<span class="token punctuation">(</span>fp<span class="token punctuation">))</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>         fread<span class="token punctuation">(</span>sample, 1, 4, fp<span class="token punctuation">)</span><span class="token punctuation">;</span>         //L         fwrite<span class="token punctuation">(</span>sample, 1, 2, fp1<span class="token punctuation">)</span><span class="token punctuation">;</span>         //R         fwrite<span class="token punctuation">(</span>sample + 2, 1, 2, fp2<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span>     free<span class="token punctuation">(</span>sample<span class="token punctuation">)</span><span class="token punctuation">;</span>     fclose<span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>     fclose<span class="token punctuation">(</span>fp1<span class="token punctuation">)</span><span class="token punctuation">;</span>     fclose<span class="token punctuation">(</span>fp2<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> 0<span class="token punctuation">;</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span></code></pre><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h2><p>PCM wiki in multimedia<br>PCM音量控制<br>PCM音频采样数据处理<br>stackoverflow/What is the difference between AV_SAMPLE_FMT_S16P and AV_SAMPLE_FMT_S16?</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android View Touch 事件分发</title>
      <link href="2019/01/15/DispatchingEvents/"/>
      <url>2019/01/15/DispatchingEvents/</url>
      
        <content type="html"><![CDATA[<h1 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h1><pre><code>在Android中，View的结构是树状的，所以触发触摸事件的时候，其事件也是从上至下一层层的传递。首先，需要了解事件处理中的几个方法：1 ViewGroup ： 事件分为 dispatchTouchEvent(事件分发)、onInterceptTouchEvent(事件拦截)、onTouchEvent(事件处理)。2 View ：事件分为 dispatchTouchEvent(事件分发)、onTouchEvent(事件处理)。</code></pre><h2 id="Demo-界面结构"><a href="#Demo-界面结构" class="headerlink" title="Demo 界面结构"></a>Demo 界面结构</h2><pre><code>由两个ViewGroup和一个自定义View组成，并重新了他们的以上方法。</code></pre><p><img src="/2019/01/15/DispatchingEvents/dispatching_event.png"></p><h3 id="MyViewGroupA-代码如下："><a href="#MyViewGroupA-代码如下：" class="headerlink" title="MyViewGroupA 代码如下："></a>MyViewGroupA 代码如下：</h3><pre><code>public class MyViewGroupA extends LinearLayout &#123;    public MyViewGroupA(Context context) &#123;        super(context);    &#125;    public MyViewGroupA(Context context, AttributeSet attrs) &#123;        super(context, attrs);    &#125;    public MyViewGroupA(Context context, AttributeSet attrs, int defStyleAttr) &#123;        super(context, attrs, defStyleAttr);    &#125;    @Override    public boolean dispatchTouchEvent(MotionEvent ev) &#123;        switch (ev.getAction())&#123;            case MotionEvent.ACTION_DOWN:                Log.i(&quot;MyViewGroupA&quot;,&quot;dispatchTouchEvent_ACTION_DOWN&quot;);                break;            case MotionEvent.ACTION_MOVE:                Log.i(&quot;MyViewGroupA&quot;,&quot;dispatchTouchEvent_ACTION_MOVE&quot;);                break;            case MotionEvent.ACTION_UP:                Log.i(&quot;MyViewGroupA&quot;,&quot;dispatchTouchEvent_ACTION_UP&quot;);                break;        &#125;        return super.dispatchTouchEvent(ev);    &#125;    @Override    public boolean onInterceptTouchEvent(MotionEvent ev) &#123;        switch (ev.getAction())&#123;            case MotionEvent.ACTION_DOWN:                Log.i(&quot;MyViewGroupA&quot;,&quot;onInterceptTouchEvent_ACTION_DOWN&quot;);                break;            case MotionEvent.ACTION_MOVE:                Log.i(&quot;MyViewGroupA&quot;,&quot;onInterceptTouchEvent_ACTION_MOVE&quot;);                break;            case MotionEvent.ACTION_UP:                Log.i(&quot;MyViewGroupA&quot;,&quot;onInterceptTouchEvent_ACTION_UP&quot;);                break;        &#125;        return super.onInterceptTouchEvent(ev);    &#125;    @Override    public boolean onTouchEvent(MotionEvent event) &#123;        switch (event.getAction())&#123;            case MotionEvent.ACTION_DOWN:                Log.i(&quot;MyViewGroupA&quot;,&quot;onTouchEvent_ACTION_DOWN&quot;);                break;            case MotionEvent.ACTION_MOVE:                Log.i(&quot;MyViewGroupA&quot;,&quot;onTouchEvent_ACTION_MOVE&quot;);                break;            case MotionEvent.ACTION_UP:                Log.i(&quot;MyViewGroupA&quot;,&quot;onTouchEvent_ACTION_UP&quot;);                break;        &#125;        return super.onTouchEvent(event);    &#125;&#125;</code></pre><h3 id="MyViewGroupB-代码如下："><a href="#MyViewGroupB-代码如下：" class="headerlink" title="MyViewGroupB 代码如下："></a>MyViewGroupB 代码如下：</h3><pre><code>public class MyViewGroupB extends LinearLayout &#123;    public MyViewGroupB(Context context) &#123;        super(context);    &#125;    public MyViewGroupB(Context context, @Nullable AttributeSet attrs) &#123;        super(context, attrs);    &#125;    public MyViewGroupB(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;        super(context, attrs, defStyleAttr);    &#125;    @Override    public boolean dispatchTouchEvent(MotionEvent ev) &#123;        switch (ev.getAction()) &#123;            case MotionEvent.ACTION_DOWN:                Log.i(&quot;MyViewGroupB&quot;,&quot;dispatchTouchEvent_ACTION_DOWN&quot;);                break;            case MotionEvent.ACTION_MOVE:                Log.i(&quot;MyViewGroupB&quot;, &quot;dispatchTouchEvent_ACTION_MOVE&quot;);                break;            case MotionEvent.ACTION_UP:                Log.i(&quot;MyViewGroupB&quot;, &quot;dispatchTouchEvent_ACTION_UP&quot;);                break;        &#125;        return super.dispatchTouchEvent(ev);    &#125;    @Override    public boolean onInterceptTouchEvent(MotionEvent ev) &#123;        switch (ev.getAction())&#123;            case MotionEvent.ACTION_DOWN:                Log.i(&quot;MyViewGroupB&quot;,&quot;onInterceptTouchEvent_ACTION_DOWN&quot;);                break;            case MotionEvent.ACTION_MOVE:                Log.i(&quot;MyViewGroupB&quot;,&quot;onInterceptTouchEvent_ACTION_MOVE&quot;);                break;            case MotionEvent.ACTION_UP:                Log.i(&quot;MyViewGroupB&quot;,&quot;onInterceptTouchEvent_ACTION_UP&quot;);                break;        &#125;        return super.onInterceptTouchEvent(ev);    &#125;    @Override    public boolean onTouchEvent(MotionEvent event) &#123;        switch (event.getAction())&#123;            case MotionEvent.ACTION_DOWN:                Log.i(&quot;MyViewGroupB&quot;,&quot;onTouchEvent_ACTION_DOWN&quot;);                break;            case MotionEvent.ACTION_MOVE:                Log.i(&quot;MyViewGroupB&quot;,&quot;onTouchEvent_ACTION_MOVE&quot;);                break;            case MotionEvent.ACTION_UP:                Log.i(&quot;MyViewGroupB&quot;,&quot;onTouchEvent_ACTION_UP&quot;);                break;        &#125;        return super.onTouchEvent(event);    &#125;&#125;</code></pre><h3 id="MyView-代码如下："><a href="#MyView-代码如下：" class="headerlink" title="MyView 代码如下："></a>MyView 代码如下：</h3><pre><code>public class MyView extends View &#123;    public MyView(Context context) &#123;        super(context);    &#125;    public MyView(Context context, @Nullable AttributeSet attrs) &#123;        super(context, attrs);    &#125;    public MyView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;        super(context, attrs, defStyleAttr);    &#125;    @Override    public boolean dispatchTouchEvent(MotionEvent event) &#123;        switch (event.getAction()) &#123;            case MotionEvent.ACTION_DOWN:                Log.i(&quot;MyView&quot;,&quot;dispatchTouchEvent_ACTION_DOWN&quot;);                break;            case MotionEvent.ACTION_MOVE:                Log.i(&quot;MyView&quot;, &quot;dispatchTouchEvent_ACTION_MOVE&quot;);                break;            case MotionEvent.ACTION_UP:                Log.i(&quot;MyView&quot;, &quot;dispatchTouchEvent_ACTION_UP&quot;);                break;        &#125;        return super.dispatchTouchEvent(event);    &#125;    @Override    public boolean onTouchEvent(MotionEvent event) &#123;        switch (event.getAction())&#123;            case MotionEvent.ACTION_DOWN:                Log.i(&quot;MyView&quot;,&quot;onTouchEvent_ACTION_DOWN&quot;);                break;            case MotionEvent.ACTION_MOVE:                Log.i(&quot;MyView&quot;,&quot;onTouchEvent_ACTION_MOVE&quot;);                break;            case MotionEvent.ACTION_UP:                Log.i(&quot;MyView&quot;,&quot;onTouchEvent_ACTION_UP&quot;);                break;        &#125;        return super.onTouchEvent(event);    &#125;&#125;</code></pre><h3 id="DispatchingEventsDemo代码如下："><a href="#DispatchingEventsDemo代码如下：" class="headerlink" title="DispatchingEventsDemo代码如下："></a>DispatchingEventsDemo代码如下：</h3><pre><code>public class DispatchingEventsDemo extends Activity &#123;    @Override    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_dispatching_event_demo);    &#125;    @Override    public boolean dispatchTouchEvent(MotionEvent ev) &#123;        switch (ev.getAction())&#123;            case MotionEvent.ACTION_DOWN:                Log.i(&quot;Activity&quot;,&quot;dispatchTouchEvent_ACTION_DOWN&quot;);                break;            case MotionEvent.ACTION_MOVE:                Log.i(&quot;Activity&quot;,&quot;dispatchTouchEvent_ACTION_MOVE&quot;);                break;            case MotionEvent.ACTION_UP:                Log.i(&quot;Activity&quot;,&quot;dispatchTouchEvent_ACTION_UP&quot;);                break;        &#125;        return super.dispatchTouchEvent(ev);    &#125;    @Override    public boolean onTouchEvent(MotionEvent event) &#123;        switch (event.getAction())&#123;            case MotionEvent.ACTION_DOWN:                Log.i(&quot;Activity&quot;,&quot;onTouchEvent_ACTION_DOWN&quot;);                break;            case MotionEvent.ACTION_MOVE:                Log.i(&quot;Activity&quot;,&quot;onTouchEvent_ACTION_MOVE&quot;);                break;            case MotionEvent.ACTION_UP:                Log.i(&quot;Activity&quot;,&quot;onTouchEvent_ACTION_UP&quot;);                break;        &#125;        return super.onTouchEvent(event);    &#125;&#125;</code></pre><h3 id="实例分析："><a href="#实例分析：" class="headerlink" title="实例分析："></a>实例分析：</h3><pre><code>    现在我们通过触摸MyView开始进行分析。虽然dispatchTouchEvent是事件开始的第一步，但是在开发中，我们通常很少改写它，        所以我们下面只讨论其他两个方法。现在我们通过触摸MyView开始进行分析。虽然dispatchTouchEvent是事件开始的第一步，        但是在开发中，我们通常很少改写它，所以我们下面只讨论其他两个方法。</code></pre><h4 id="1、对以上方法均不作处理，都返回super。这意味着我们既不拦截，也不消费。"><a href="#1、对以上方法均不作处理，都返回super。这意味着我们既不拦截，也不消费。" class="headerlink" title="1、对以上方法均不作处理，都返回super。这意味着我们既不拦截，也不消费。"></a>1、对以上方法均不作处理，都返回super。这意味着我们既不拦截，也不消费。</h4><pre><code>    大家看输出结果：    I/Activity: dispatchTouchEvent_ACTION_DOWN    I/MyViewGroupA: dispatchTouchEvent_ACTION_DOWN    I/MyViewGroupA: onInterceptTouchEvent_ACTION_DOWN    I/MyViewGroupB: dispatchTouchEvent_ACTION_DOWN    I/MyViewGroupB: onInterceptTouchEvent_ACTION_DOWN    I/MyView: dispatchTouchEvent_ACTION_DOWN    I/MyView: onTouchEvent_ACTION_DOWN    I/MyViewGroupB: onTouchEvent_ACTION_DOWN    I/MyViewGroupA: onTouchEvent_ACTION_DOWN    I/Activity: onTouchEvent_ACTION_DOWN    I/Activity: dispatchTouchEvent_ACTION_MOVE    I/Activity: onTouchEvent_ACTION_MOVE    I/Activity: dispatchTouchEvent_ACTION_UP    I/Activity: onTouchEvent_ACTION_UP    结合输出结果，我们可以总结出以下的结论：</code></pre><p><img src="/2019/01/15/DispatchingEvents/1.jpg"><br><img src="/2019/01/15/DispatchingEvents/2.jpg"><br>        结合流程图，不难发现，如果我对事件既不拦截，也不消费，当触发ACTION_DOWN的时候，事件会经过Activity——MyViewGroupA——MyViewGroupB——MyView一层层的向下进行dispatchTouchEvent（分发）—onInterceptTouchEvent（拦截）调用。当到达最底层MyView后，开始触发消费操作，因为我均不消费，ACTION_DOWN将由底层一层层向上冒，移交上层处理。当抵达最上层Activity后，说明下层均不消费，之后触发的ACTION_MOVE和ACTION_UP将不再向下层分发传递，直接交由Activity分发给自己进行处理。</p><h4 id="2、我们将MyVIewGroupB的onInterceptTouchEvent返回值改为true，其他均是super。这意味着仅仅MyViewGroupB进行事件拦截，但均无消费"><a href="#2、我们将MyVIewGroupB的onInterceptTouchEvent返回值改为true，其他均是super。这意味着仅仅MyViewGroupB进行事件拦截，但均无消费" class="headerlink" title="2、我们将MyVIewGroupB的onInterceptTouchEvent返回值改为true，其他均是super。这意味着仅仅MyViewGroupB进行事件拦截，但均无消费"></a>2、我们将MyVIewGroupB的onInterceptTouchEvent返回值改为true，其他均是super。这意味着仅仅MyViewGroupB进行事件拦截，但均无消费</h4><pre><code>    输出结果如下：    I/Activity: dispatchTouchEvent_ACTION_DOWN    I/MyViewGroupA: dispatchTouchEvent_ACTION_DOWN    I/MyViewGroupA: onInterceptTouchEvent_ACTION_DOWN    I/MyViewGroupB: dispatchTouchEvent_ACTION_DOWN    I/MyViewGroupB: onInterceptTouchEvent_ACTION_DOWN    I/MyViewGroupB: onTouchEvent_ACTION_DOWN    I/MyViewGroupA: onTouchEvent_ACTION_DOWN    I/Activity: onTouchEvent_ACTION_DOWN    I/Activity: dispatchTouchEvent_ACTION_MOVE    I/Activity: onTouchEvent_ACTION_MOVE    I/Activity: dispatchTouchEvent_ACTION_UP    I/Activity: onTouchEvent_ACTION_UP    结合输出结果，总结如下：</code></pre><p><img src="/2019/01/15/DispatchingEvents/3.jpg"><br><img src="/2019/01/15/DispatchingEvents/4.jpg"></p><pre><code>    当触发ACTION_DOWN的时候，事件依然是从Activity开始一层层向下传递，当传递到MyViewGroupB时，因为进行了事件拦截，所以执行完onInterceptTouchEvent后不再向下传递，而是直接交由MyViewGroupB的onTouchEvent进行消费处理。由于我们是只拦截，不消费，所以事件向上传递，交由上层处理，最终回到Activity。之后触发的ACTION_MOVE和ACTION_UP也不再向下传递，直接交由Activity分发给自己处理。</code></pre><h4 id="3、我们还是将MyViewGroupB的onInterceptTouchEvent返回super，但是将他的onTouchEvent返回true。这意味着我们不拦截，但是由MyViewGroupB进行事件处理。"><a href="#3、我们还是将MyViewGroupB的onInterceptTouchEvent返回super，但是将他的onTouchEvent返回true。这意味着我们不拦截，但是由MyViewGroupB进行事件处理。" class="headerlink" title="3、我们还是将MyViewGroupB的onInterceptTouchEvent返回super，但是将他的onTouchEvent返回true。这意味着我们不拦截，但是由MyViewGroupB进行事件处理。"></a>3、我们还是将MyViewGroupB的onInterceptTouchEvent返回super，但是将他的onTouchEvent返回true。这意味着我们不拦截，但是由MyViewGroupB进行事件处理。</h4><pre><code>    输出结果如下：    I/Activity: dispatchTouchEvent_ACTION_DOWN    I/MyViewGroupA: dispatchTouchEvent_ACTION_DOWN    I/MyViewGroupA: onInterceptTouchEvent_ACTION_DOWN    I/MyViewGroupB: dispatchTouchEvent_ACTION_DOWN    I/MyViewGroupB: onInterceptTouchEvent_ACTION_DOWN    I/MyView: dispatchTouchEvent_ACTION_DOWN    I/MyView: onTouchEvent_ACTION_DOWN    I/MyViewGroupB: onTouchEvent_ACTION_DOWN    I/Activity: dispatchTouchEvent_ACTION_MOVE    I/MyViewGroupA: dispatchTouchEvent_ACTION_MOVE    I/MyViewGroupA: onInterceptTouchEvent_ACTION_MOVE    I/MyViewGroupB: dispatchTouchEvent_ACTION_MOVE    I/MyViewGroupB: onTouchEvent_ACTION_MOVE    I/Activity: dispatchTouchEvent_ACTION_UP    I/MyViewGroupA: dispatchTouchEvent_ACTION_UP    I/MyViewGroupA: onInterceptTouchEvent_ACTION_UP    I/MyViewGroupB: dispatchTouchEvent_ACTION_UP    I/MyViewGroupB: onTouchEvent_ACTION_UP    结合输出结果，总结如下：</code></pre><p><img src="/2019/01/15/DispatchingEvents/5.jpg"><br><img src="/2019/01/15/DispatchingEvents/6.jpg"></p><pre><code>    可以看出，当触发ACTION_DOWN的时候，事件的分发传递过程和1的时候一样，从Activity开始一层层向下传递，最终传递到最底层MyView，触发消费操作，然后MyView将消费操作移交上层处理，然后到达MyViewGroupB的onTouchEvent，并且进行了消费处理，事件处理到此不在向上移交。当触发ACTION_MOVE和ACTION_UP操作时，事件依然需要由Activity开始向下分发传递，但是当传递到MyViewGroupB后，由于其消费了ACTION_DOWN，事件将不再继续向下分发，而是直接由MyViewGroupB分发给自己的onTouchEvent进行继续处理。事件处理也不再向上移交。</code></pre><h4 id="4、将MyViewGroupB的onInterceptTouchEvent和onTouchEvent的返回值均改为true。这意味着既拦截，又消费。"><a href="#4、将MyViewGroupB的onInterceptTouchEvent和onTouchEvent的返回值均改为true。这意味着既拦截，又消费。" class="headerlink" title="4、将MyViewGroupB的onInterceptTouchEvent和onTouchEvent的返回值均改为true。这意味着既拦截，又消费。"></a>4、将MyViewGroupB的onInterceptTouchEvent和onTouchEvent的返回值均改为true。这意味着既拦截，又消费。</h4><pre><code>    输出结果如下：    I/Activity: dispatchTouchEvent_ACTION_DOWN    I/MyViewGroupA: dispatchTouchEvent_ACTION_DOWN    I/MyViewGroupA: onInterceptTouchEvent_ACTION_DOWN    I/MyViewGroupB: dispatchTouchEvent_ACTION_DOWN    I/MyViewGroupB: onInterceptTouchEvent_ACTION_DOWN    I/MyViewGroupB: onTouchEvent_ACTION_DOWN    I/Activity: dispatchTouchEvent_ACTION_MOVE    I/MyViewGroupA: dispatchTouchEvent_ACTION_MOVE    I/MyViewGroupA: onInterceptTouchEvent_ACTION_MOVE    I/MyViewGroupB: dispatchTouchEvent_ACTION_MOVE    I/MyViewGroupB: onTouchEvent_ACTION_MOVE    I/Activity: dispatchTouchEvent_ACTION_UP    I/MyViewGroupA: dispatchTouchEvent_ACTION_UP    I/MyViewGroupA: onInterceptTouchEvent_ACTION_UP    I/MyViewGroupB: dispatchTouchEvent_ACTION_UP    I/MyViewGroupB: onTouchEvent_ACTION_UP    结合输出结果，总结如下：    </code></pre><p><img src="/2019/01/15/DispatchingEvents/7.jpg"><br><img src="/2019/01/15/DispatchingEvents/8.jpg"><br>        当触发ACTION_DOWN的时候，依然从Activity开始向下传递，当到达MyViewGroupB的是，因为在onInterceptTouchEvent进行了拦截操作，因此不再继续向下分发传递，而是交由MyViewGroupB的onTouchEvent进行处理消费。MyViewGroupB的onTouchEvent返回的是true，说明它决定对ACTION_DOWN进行处理，因此事件也就不再移交上层处理。当触发ACTION_MOVE和ACTION_UP的时候，事件还是从Activity开始向下传递，当到达MyViewGroupB的时候，由于之前进行了拦截操作，因此，MyViewGroupB直接将事件分发给自己的onTouchEvent进行处理，不在向下分发传递。事件处理也不再向上层移交。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于eclipse进行ndk开发： JNI</title>
      <link href="2018/11/20/JNI-CONFIG/"/>
      <url>2018/11/20/JNI-CONFIG/</url>
      
        <content type="html"><![CDATA[<h1 id="JNI-简介"><a href="#JNI-简介" class="headerlink" title="JNI 简介"></a>JNI 简介</h1><pre><code>JNI是Java Native Interface的缩写，即Java本地调用。从Java1.1开始，JNI标准成为Java平台的一部分，它允许Java虚拟机（JVM）内部运行的Java代码能够与用其它编程语言(如 C、C++ 和汇编语言)编写的应用程序和库进行交互操作。</code></pre><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><pre><code>1 计算器 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量     新建-&gt;  变量名：ANDROID_SDK_HOME             变量值：D:\ProgramFiles\Android\android-sdk-windows            </code></pre><p><img src="/2018/11/20/JNI-CONFIG/windows_sdk_config.png"></p><pre><code>2 Android 指定NDK的位置    打开eclipse，从菜单栏依次选择，Windows -&gt; Preferences -&gt; Android，通过Browser选择ndk正确的路径，OK完成。</code></pre><p><img src="/2018/11/20/JNI-CONFIG/eclipse_ndk_config.png"></p><pre><code>3 C/C++ 配置NDK目录打开eclipse，从菜单栏依次选择，Windows -&gt; Preferences -&gt; C/C++-&gt; build -&gt; Environment;Add New variable -&gt; Name : NDK_ROOT                    Value : D:\ProgramFiles\Android\android-ndk-r10                    </code></pre><p><img src="/2018/11/20/JNI-CONFIG/ndk_path_config.png">        </p><pre><code>4 配置eclipse 的 javaH 命令， 生成头文件工具Run-&gt;External Tools-&gt;External Tools Configurations左侧栏里选中Program，单击左上角的New launch configuration，再单击Main选项卡，按照如下信息填写，需要确保Android sdk路径下有类似android-19的文件夹，根据自己sdk实际情况调整。        NAME:  Generate C and C++ Header File        Location:  $&#123;system_path:javah&#125;        Working Directory:  $&#123;project_loc&#125;/jni            Arguments:  -classpath &quot;$&#123;project_classpath&#125;;                $&#123;env_var:ANDROID_SDK_HOME&#125;/platforms/android-19/android.jar&quot;                 $&#123;java_type_name&#125;        </code></pre><p>![](JNI-CONFIG/generate_c _and_c++_header_file.png)</p><h2 id="Eclipse-创建-Demo"><a href="#Eclipse-创建-Demo" class="headerlink" title="Eclipse 创建 Demo"></a>Eclipse 创建 Demo</h2><pre><code>1 创建Android工程File -&gt; NEW -&gt; Android Application Project -&gt; Next -&gt; Finish;</code></pre><p><img src="/2018/11/20/JNI-CONFIG/new_android_application_project.png"></p><pre><code>2 项目添加原生支持 所谓原生支持，就是本地支持，也就是native支持，也就是支持JAVA和C/C++混编。Add Native Supportdemo工程(MyJniDemo) -&gt; 右键 -&gt; Android Tools -&gt; Add Native Support</code></pre><p><img src="/2018/11/20/JNI-CONFIG/add_android_native_support.png"></p><pre><code>执行完成后，将会在jni目录下生成         MyJniDemo.cpp                Android.mk                         LOCAL_PATH := $(call my-dir)                                 include $(CLEAR_VARS)                 LOCAL_MODULE    := MyJniDemo                 LOCAL_SRC_FILES := MyJniDemo.cpp                 include $(BUILD_SHARED_LIBRARY)                 </code></pre><p><img src="/2018/11/20/JNI-CONFIG/add_android_native_support_1.png"></p><pre><code>3 配置C/C++ Build点击C/C++ Build -&gt; 选中Builder Settings -&gt; 配置 Build command : $&#123;NDK_ROOT&#125;/ndk-build.cmd </code></pre><p><img src="/2018/11/20/JNI-CONFIG/c_build_config.png"></p><pre><code>4 生成头文件选中需要生成.h 头文件的java类，右键run -&gt; External Tools -&gt; Generate C and C++ Header File编译成功后，会在jni文件夹下生成 对应包名 + 类名的.h 头文件(eg: com_example_myjnidemo_MyJniActivity.h)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cocos2dx</title>
      <link href="2018/09/16/cocos2dx/"/>
      <url>2018/09/16/cocos2dx/</url>
      
        <content type="html"><![CDATA[<h2 id="cocos2dx-2-2-6-Eclipse-开发"><a href="#cocos2dx-2-2-6-Eclipse-开发" class="headerlink" title="cocos2dx 2.2.6 + Eclipse 开发"></a>cocos2dx 2.2.6 + Eclipse 开发</h2><h3 id="下载安装-Eclipse"><a href="#下载安装-Eclipse" class="headerlink" title="下载安装 Eclipse"></a>下载安装 Eclipse</h3><h3 id="下载cocos2dx-2-2-6-解压到-D-cocos2dx"><a href="#下载cocos2dx-2-2-6-解压到-D-cocos2dx" class="headerlink" title="下载cocos2dx 2.2.6  解压到 D:\cocos2dx"></a>下载cocos2dx 2.2.6  解压到 D:\cocos2dx</h3><pre><code>cocos2dx2.2.6 解压路径：D:\cocos2dx\cocos2d-x-2.2.6</code></pre><h3 id="用Python创建自己的工程"><a href="#用Python创建自己的工程" class="headerlink" title="用Python创建自己的工程"></a>用Python创建自己的工程</h3><pre><code>下载 [Python](https://www.python.org/downloads/release/python-2715/) Windows x86-64 MSI installer，安装过程忽略。安装完Python之后，打开命令窗口(windows 命令窗口)，``` bash$ python -v $ Python 2.7.15```Create cocos2dx Demo``` bash$ cd D:\cocos2dx\cocos2d-x-2.2.6\tools\project-creator$ D:\cocos2dx\cocos2d-x-2.2.6\tools\project-creator&gt;create_project.py -project MyTest -package com.sky.demo -language cpp```工程就创建好了路径：D:\cocos2dx\cocos2d-x-2.2.6\projects</code></pre><h3 id="Ecplise-编译-Demo-工程"><a href="#Ecplise-编译-Demo-工程" class="headerlink" title="Ecplise 编译 Demo 工程"></a>Ecplise 编译 Demo 工程</h3><pre><code>导入创建好的MyTest工程打开Eclipse, File -&gt; Import -&gt; Android -&gt; Existing Android Code Into Workspace (不勾选 Copy project into workspace)-&gt; Root Directiory: D:\cocos2dx\cocos2d-x-2.2.6\projects\MyTest\proj.android -&gt; Finish导入cocos2dx lib (不勾选 Copy project into workspace)打开Eclipse, File -&gt; Import -&gt; Android -&gt; Existing Android Code Into Workspace -&gt; Root Directiory: D:\cocos2dx\cocos2d-x-2.2.6\cocos2dx\platform\android\java -&gt; Finish配置属性MyTest MODEL 右键 Properties     -&gt; Android -&gt; Add libcocos2dx    -&gt; C/C++ Build -&gt; Builder Settings -&gt; Build command: D:\ProgramFiles\Android\android-ndk-r10\ndk-build.cmdjni    -&gt; Application.mk -&gt;         添加         NDK_MODULE_PATH:= D:/cocos2dx/cocos2d-x-2.2.6;D:/cocos2dx/cocos2d-x-2.2.6/cocos2dx/platform/third_party/android/prebuilt</code></pre><h2 id="cocos2d-x-3-17-VS-2017-开发"><a href="#cocos2d-x-3-17-VS-2017-开发" class="headerlink" title="cocos2d-x-3.17 + VS 2017 开发"></a>cocos2d-x-3.17 + VS 2017 开发</h2><h3 id="下载安装-VS-2017-、-Android-Studio"><a href="#下载安装-VS-2017-、-Android-Studio" class="headerlink" title="下载安装 VS 2017 、 Android Studio"></a>下载安装 VS 2017 、 Android Studio</h3><h3 id="下载cocos2dx-3-1-7-解压到-D-cocos2dx"><a href="#下载cocos2dx-3-1-7-解压到-D-cocos2dx" class="headerlink" title="下载cocos2dx 3.1.7  解压到 D:\cocos2dx"></a>下载cocos2dx 3.1.7  解压到 D:\cocos2dx</h3><pre><code>cocos2dx3.1.7 解压路径：D:\cocos2dx\cocos2d-x-3.17</code></pre><h3 id="用Python创建自己的工程-1"><a href="#用Python创建自己的工程-1" class="headerlink" title="用Python创建自己的工程"></a>用Python创建自己的工程</h3><pre><code>下载 [Python](https://www.python.org/downloads/release/python-2715/) Windows x86-64 MSI installer，安装过程忽略。安装完Python之后，打开命令窗口(windows 命令窗口)，``` bash$ python -v $ Python 2.7.15```Create cocos2dx Demo``` bash$ cd D:\cocos2dx\cocos2d-x-3.17\tools\cocos2d-console\bin$ D:\cocos2dx\cocos2d-x-3.17\tools\cocos2d-console\bin&gt; cocos new myTestGame -p com.cocos2dx.demo -d F:\coco2dxwork -l cpp ```工程就创建好了路径：F:\coco2dxwork\myTestGame</code></pre><h3 id="Android-Studio-编译-Demo-工程"><a href="#Android-Studio-编译-Demo-工程" class="headerlink" title="Android Studio 编译 Demo 工程"></a>Android Studio 编译 Demo 工程</h3><pre><code>打开创建好的myTestGame工程打开Android Studio, File -&gt; Open -&gt; F:\coco2dxwork\myTestGame\proj.android</code></pre><h3 id="VS2017-编译-Demo-工程"><a href="#VS2017-编译-Demo-工程" class="headerlink" title="VS2017 编译 Demo 工程"></a>VS2017 编译 Demo 工程</h3><pre><code>打开创建好的myTestGame工程打开Android Studio, File -&gt; Open -&gt; F:\coco2dxwork\myTestGame\proj.win32    </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10 MongoDB安装配置启动</title>
      <link href="2017/05/03/MongoDB/"/>
      <url>2017/05/03/MongoDB/</url>
      
        <content type="html"><![CDATA[<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>下载[MongoDB](https://www.mongodb.com/) mongodb-win32-x86_64-2008plus-ssl-3.4.4-signed.msi。双击安装，直接next，直到finish。默认安装目录是C:\Program Files\MongoDB.我这里移动到D:\MongoDB.之所以不选择Program Files文件夹是因为中间有空格。后续的配置文件，路径不能有空格。</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><pre><code>1 配置环境变量:D:\MongoDB\Server\3.4\bin2 在D:\MongoDB\下新建data文件夹，进入data，新建db和logs文件3 指定保存数据地址，在(以管理员身份运行)cmd中键入 mongod  --dbpath  D:\MongoDB\data\db4 前面是安装路径，后面是刚刚建立db文件夹的路径5 在cmd中键入  mongod6 等待出现waiting forconnection ，不要关闭当前cmd，在打开cmd，键入mongo(不要写成mongod) 之后有一个cmd会出现，connecting to :test，关闭两个cmd7 打开cmd，键入 mkdir  D:\mongodb\Data\logs   关闭cmd 在D:\MongoDB下建立一个mongod.cfg文件，在文件里面键入    systemLog:        destination: file        path: D:\MongoDB\data\logs\mong.log    storage:        dbPath: D:\MongoDB\data\db9 以管理员权限打开cmd，键入mongod --config &quot;D:\mongodb\mongod.cfg&quot; --install之后去logs看，会出现一个新文件</code></pre><h3 id="连接调试"><a href="#连接调试" class="headerlink" title="连接调试"></a>连接调试</h3><pre><code>cmd下键入 net start  mongodb  开始连接          net stop mongodb    终止连接</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>利用hexo搭建个人博客for windows</title>
      <link href="2017/05/03/hexo/"/>
      <url>2017/05/03/hexo/</url>
      
        <content type="html"><![CDATA[<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="安装-GIT"><a href="#安装-GIT" class="headerlink" title="安装 GIT"></a>安装 GIT</h3><p>下载<a href="https://git-scm.com/">Git</a>，安装过程忽略。</p><h3 id="安装-nvm（Node-js版本管理工具）"><a href="#安装-nvm（Node-js版本管理工具）" class="headerlink" title="安装 nvm（Node.js版本管理工具）"></a>安装 nvm（Node.js版本管理工具）</h3><p><a href="https://github.com/coreybutler/nvm-windows/releases">nvm</a> ，选择 nvm-setup.zip 下载</p><p>解压后，点击nvm-setup进行安装，可以选择默认路径，可以自定义路径。</p><p>我的默认路径（可自定义）：    </p><pre class=" language-bash"><code class="language-bash">root: C:\Users\Administrator\AppData\Roaming\nvmpath: C:\Program Files\nodejs</code></pre><p>安装完nvm之后，打开命令窗口(windows 命令窗口或者git bash 均可)，</p><pre class=" language-bash"><code class="language-bash">$ nvm -v $ 1.1.1</code></pre><h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h3><p>继第2步之后，</p><pre class=" language-bash"><code class="language-bash">$ nvm <span class="token function">install</span> latest $ node -v $ v6.5.0 </code></pre><p>这是下载Node.js的最新版本，也可以指定某一版本。<a href="https://nodejs.org/]https://nodejs.org/">Node.js官网</a></p><p>Node.js安装完毕。在此过程中会将 npm 安装</p><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>安装 Hexo ：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli $ Hexo <span class="token function">v</span></code></pre><p>安装完成后可以查看版本信息 </p><h3 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h3><p>我是在D：盘新建 myblog 文件夹，进入myblog 执行 </p><p>init</p><pre class=" language-bash"><code class="language-bash">$ hexo init <span class="token punctuation">[</span>folder<span class="token punctuation">]</span></code></pre><p>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</p><p>new</p><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>title<span class="token operator">></span></code></pre><p>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p><p>generate</p><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>生成静态文件。</p><p>server</p><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p> 启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/">http://localhost:4000/</a></p><p> 到此，本地就可以博客就可以访问了。</p><h3 id="部署-github"><a href="#部署-github" class="headerlink" title="部署 github"></a>部署 github</h3><p>建立Repository</p><p>建立与你用户名对应仓库，仓库名必须是【your_user_name.github.io】,固定写法</p><p>建立关联</p><p>我的blog地址是 D:\myblog ，在此文件夹下找到配置文件 _config.yml</p><p>deploy:</p><pre><code>  type: git  repo: https://github.com/[yourname]/[yourname].github.io.git  branch: master</code></pre><p>将 yourname 替换成你的用户名</p><p>然后执行</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git --save</code></pre><p>上传本地代码到github</p><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>浏览器中输入<a href="http://yourname.github.io/">http://yourname.github.io/</a> , OK 了</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="http://blog.csdn.net/tyro_java/article/details/51232458">http://blog.csdn.net/tyro_java/article/details/51232458</a><br><a href="http://kaizige.vip/2016/06/10/how-to-build-up-yourself-hexo-blog/">http://kaizige.vip/2016/06/10/how-to-build-up-yourself-hexo-blog/</a><br><a href="http://ibruce.info/2013/11/22/hexo-your-blog/?utm_source=tuicool&amp;utm_medium=referralaio">http://ibruce.info/2013/11/22/hexo-your-blog/?utm_source=tuicool&amp;utm_medium=referralaio</a><br><a href="http://www.jianshu.com/p/465830080ea9">http://www.jianshu.com/p/465830080ea9</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2017/05/01/hello-world/"/>
      <url>2017/05/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
