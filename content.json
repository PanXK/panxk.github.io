{"meta":{"title":"急速蜗牛","subtitle":"静以修身，俭以养德","description":"","author":"snail","url":"http://panxk.github.io","root":"/"},"pages":[{"title":"categories","date":"2021-04-06T05:58:29.000Z","updated":"2021-04-06T05:59:06.587Z","comments":true,"path":"categories/index.html","permalink":"http://panxk.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-04-06T06:00:32.000Z","updated":"2021-04-06T06:00:46.757Z","comments":true,"path":"tags/index.html","permalink":"http://panxk.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2021-04-06T06:01:44.000Z","updated":"2021-04-06T06:01:59.309Z","comments":true,"path":"about/index.html","permalink":"http://panxk.github.io/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-04-06T06:06:33.000Z","updated":"2021-04-06T06:08:43.638Z","comments":true,"path":"friends/index.html","permalink":"http://panxk.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"Android View Touch 事件分发","slug":"DispatchingEvents","date":"2019-01-15T07:38:41.000Z","updated":"2019-01-15T08:58:24.000Z","comments":true,"path":"2019/01/15/DispatchingEvents/","link":"","permalink":"http://panxk.github.io/2019/01/15/DispatchingEvents/","excerpt":"","text":"概述：在Android中，View的结构是树状的，所以触发触摸事件的时候，其事件也是从上至下一层层的传递。 首先，需要了解事件处理中的几个方法： 1 ViewGroup ： 事件分为 dispatchTouchEvent(事件分发)、onInterceptTouchEvent(事件拦截)、onTouchEvent(事件处理)。 2 View ：事件分为 dispatchTouchEvent(事件分发)、onTouchEvent(事件处理)。 Demo 界面结构由两个ViewGroup和一个自定义View组成，并重新了他们的以上方法。 MyViewGroupA 代码如下：public class MyViewGroupA extends LinearLayout &#123; public MyViewGroupA(Context context) &#123; super(context); &#125; public MyViewGroupA(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public MyViewGroupA(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; switch (ev.getAction())&#123; case MotionEvent.ACTION_DOWN: Log.i(&quot;MyViewGroupA&quot;,&quot;dispatchTouchEvent_ACTION_DOWN&quot;); break; case MotionEvent.ACTION_MOVE: Log.i(&quot;MyViewGroupA&quot;,&quot;dispatchTouchEvent_ACTION_MOVE&quot;); break; case MotionEvent.ACTION_UP: Log.i(&quot;MyViewGroupA&quot;,&quot;dispatchTouchEvent_ACTION_UP&quot;); break; &#125; return super.dispatchTouchEvent(ev); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; switch (ev.getAction())&#123; case MotionEvent.ACTION_DOWN: Log.i(&quot;MyViewGroupA&quot;,&quot;onInterceptTouchEvent_ACTION_DOWN&quot;); break; case MotionEvent.ACTION_MOVE: Log.i(&quot;MyViewGroupA&quot;,&quot;onInterceptTouchEvent_ACTION_MOVE&quot;); break; case MotionEvent.ACTION_UP: Log.i(&quot;MyViewGroupA&quot;,&quot;onInterceptTouchEvent_ACTION_UP&quot;); break; &#125; return super.onInterceptTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN: Log.i(&quot;MyViewGroupA&quot;,&quot;onTouchEvent_ACTION_DOWN&quot;); break; case MotionEvent.ACTION_MOVE: Log.i(&quot;MyViewGroupA&quot;,&quot;onTouchEvent_ACTION_MOVE&quot;); break; case MotionEvent.ACTION_UP: Log.i(&quot;MyViewGroupA&quot;,&quot;onTouchEvent_ACTION_UP&quot;); break; &#125; return super.onTouchEvent(event); &#125; &#125; MyViewGroupB 代码如下：public class MyViewGroupB extends LinearLayout &#123; public MyViewGroupB(Context context) &#123; super(context); &#125; public MyViewGroupB(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public MyViewGroupB(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: Log.i(&quot;MyViewGroupB&quot;,&quot;dispatchTouchEvent_ACTION_DOWN&quot;); break; case MotionEvent.ACTION_MOVE: Log.i(&quot;MyViewGroupB&quot;, &quot;dispatchTouchEvent_ACTION_MOVE&quot;); break; case MotionEvent.ACTION_UP: Log.i(&quot;MyViewGroupB&quot;, &quot;dispatchTouchEvent_ACTION_UP&quot;); break; &#125; return super.dispatchTouchEvent(ev); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; switch (ev.getAction())&#123; case MotionEvent.ACTION_DOWN: Log.i(&quot;MyViewGroupB&quot;,&quot;onInterceptTouchEvent_ACTION_DOWN&quot;); break; case MotionEvent.ACTION_MOVE: Log.i(&quot;MyViewGroupB&quot;,&quot;onInterceptTouchEvent_ACTION_MOVE&quot;); break; case MotionEvent.ACTION_UP: Log.i(&quot;MyViewGroupB&quot;,&quot;onInterceptTouchEvent_ACTION_UP&quot;); break; &#125; return super.onInterceptTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN: Log.i(&quot;MyViewGroupB&quot;,&quot;onTouchEvent_ACTION_DOWN&quot;); break; case MotionEvent.ACTION_MOVE: Log.i(&quot;MyViewGroupB&quot;,&quot;onTouchEvent_ACTION_MOVE&quot;); break; case MotionEvent.ACTION_UP: Log.i(&quot;MyViewGroupB&quot;,&quot;onTouchEvent_ACTION_UP&quot;); break; &#125; return super.onTouchEvent(event); &#125; &#125; MyView 代码如下：public class MyView extends View &#123; public MyView(Context context) &#123; super(context); &#125; public MyView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public MyView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override public boolean dispatchTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: Log.i(&quot;MyView&quot;,&quot;dispatchTouchEvent_ACTION_DOWN&quot;); break; case MotionEvent.ACTION_MOVE: Log.i(&quot;MyView&quot;, &quot;dispatchTouchEvent_ACTION_MOVE&quot;); break; case MotionEvent.ACTION_UP: Log.i(&quot;MyView&quot;, &quot;dispatchTouchEvent_ACTION_UP&quot;); break; &#125; return super.dispatchTouchEvent(event); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN: Log.i(&quot;MyView&quot;,&quot;onTouchEvent_ACTION_DOWN&quot;); break; case MotionEvent.ACTION_MOVE: Log.i(&quot;MyView&quot;,&quot;onTouchEvent_ACTION_MOVE&quot;); break; case MotionEvent.ACTION_UP: Log.i(&quot;MyView&quot;,&quot;onTouchEvent_ACTION_UP&quot;); break; &#125; return super.onTouchEvent(event); &#125; &#125; DispatchingEventsDemo代码如下：public class DispatchingEventsDemo extends Activity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_dispatching_event_demo); &#125; @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; switch (ev.getAction())&#123; case MotionEvent.ACTION_DOWN: Log.i(&quot;Activity&quot;,&quot;dispatchTouchEvent_ACTION_DOWN&quot;); break; case MotionEvent.ACTION_MOVE: Log.i(&quot;Activity&quot;,&quot;dispatchTouchEvent_ACTION_MOVE&quot;); break; case MotionEvent.ACTION_UP: Log.i(&quot;Activity&quot;,&quot;dispatchTouchEvent_ACTION_UP&quot;); break; &#125; return super.dispatchTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN: Log.i(&quot;Activity&quot;,&quot;onTouchEvent_ACTION_DOWN&quot;); break; case MotionEvent.ACTION_MOVE: Log.i(&quot;Activity&quot;,&quot;onTouchEvent_ACTION_MOVE&quot;); break; case MotionEvent.ACTION_UP: Log.i(&quot;Activity&quot;,&quot;onTouchEvent_ACTION_UP&quot;); break; &#125; return super.onTouchEvent(event); &#125; &#125; 实例分析： 现在我们通过触摸MyView开始进行分析。虽然dispatchTouchEvent是事件开始的第一步，但是在开发中，我们通常很少改写它， 所以我们下面只讨论其他两个方法。现在我们通过触摸MyView开始进行分析。虽然dispatchTouchEvent是事件开始的第一步， 但是在开发中，我们通常很少改写它，所以我们下面只讨论其他两个方法。 1、对以上方法均不作处理，都返回super。这意味着我们既不拦截，也不消费。 大家看输出结果： I/Activity: dispatchTouchEvent_ACTION_DOWN I/MyViewGroupA: dispatchTouchEvent_ACTION_DOWN I/MyViewGroupA: onInterceptTouchEvent_ACTION_DOWN I/MyViewGroupB: dispatchTouchEvent_ACTION_DOWN I/MyViewGroupB: onInterceptTouchEvent_ACTION_DOWN I/MyView: dispatchTouchEvent_ACTION_DOWN I/MyView: onTouchEvent_ACTION_DOWN I/MyViewGroupB: onTouchEvent_ACTION_DOWN I/MyViewGroupA: onTouchEvent_ACTION_DOWN I/Activity: onTouchEvent_ACTION_DOWN I/Activity: dispatchTouchEvent_ACTION_MOVE I/Activity: onTouchEvent_ACTION_MOVE I/Activity: dispatchTouchEvent_ACTION_UP I/Activity: onTouchEvent_ACTION_UP 结合输出结果，我们可以总结出以下的结论： 结合流程图，不难发现，如果我对事件既不拦截，也不消费，当触发ACTION_DOWN的时候，事件会经过Activity——MyViewGroupA——MyViewGroupB——MyView一层层的向下进行dispatchTouchEvent（分发）—onInterceptTouchEvent（拦截）调用。当到达最底层MyView后，开始触发消费操作，因为我均不消费，ACTION_DOWN将由底层一层层向上冒，移交上层处理。当抵达最上层Activity后，说明下层均不消费，之后触发的ACTION_MOVE和ACTION_UP将不再向下层分发传递，直接交由Activity分发给自己进行处理。 2、我们将MyVIewGroupB的onInterceptTouchEvent返回值改为true，其他均是super。这意味着仅仅MyViewGroupB进行事件拦截，但均无消费 输出结果如下： I/Activity: dispatchTouchEvent_ACTION_DOWN I/MyViewGroupA: dispatchTouchEvent_ACTION_DOWN I/MyViewGroupA: onInterceptTouchEvent_ACTION_DOWN I/MyViewGroupB: dispatchTouchEvent_ACTION_DOWN I/MyViewGroupB: onInterceptTouchEvent_ACTION_DOWN I/MyViewGroupB: onTouchEvent_ACTION_DOWN I/MyViewGroupA: onTouchEvent_ACTION_DOWN I/Activity: onTouchEvent_ACTION_DOWN I/Activity: dispatchTouchEvent_ACTION_MOVE I/Activity: onTouchEvent_ACTION_MOVE I/Activity: dispatchTouchEvent_ACTION_UP I/Activity: onTouchEvent_ACTION_UP 结合输出结果，总结如下： 当触发ACTION_DOWN的时候，事件依然是从Activity开始一层层向下传递，当传递到MyViewGroupB时，因为进行了事件拦截，所以执行完onInterceptTouchEvent后不再向下传递，而是直接交由MyViewGroupB的onTouchEvent进行消费处理。由于我们是只拦截，不消费，所以事件向上传递，交由上层处理，最终回到Activity。之后触发的ACTION_MOVE和ACTION_UP也不再向下传递，直接交由Activity分发给自己处理。 3、我们还是将MyViewGroupB的onInterceptTouchEvent返回super，但是将他的onTouchEvent返回true。这意味着我们不拦截，但是由MyViewGroupB进行事件处理。 输出结果如下： I/Activity: dispatchTouchEvent_ACTION_DOWN I/MyViewGroupA: dispatchTouchEvent_ACTION_DOWN I/MyViewGroupA: onInterceptTouchEvent_ACTION_DOWN I/MyViewGroupB: dispatchTouchEvent_ACTION_DOWN I/MyViewGroupB: onInterceptTouchEvent_ACTION_DOWN I/MyView: dispatchTouchEvent_ACTION_DOWN I/MyView: onTouchEvent_ACTION_DOWN I/MyViewGroupB: onTouchEvent_ACTION_DOWN I/Activity: dispatchTouchEvent_ACTION_MOVE I/MyViewGroupA: dispatchTouchEvent_ACTION_MOVE I/MyViewGroupA: onInterceptTouchEvent_ACTION_MOVE I/MyViewGroupB: dispatchTouchEvent_ACTION_MOVE I/MyViewGroupB: onTouchEvent_ACTION_MOVE I/Activity: dispatchTouchEvent_ACTION_UP I/MyViewGroupA: dispatchTouchEvent_ACTION_UP I/MyViewGroupA: onInterceptTouchEvent_ACTION_UP I/MyViewGroupB: dispatchTouchEvent_ACTION_UP I/MyViewGroupB: onTouchEvent_ACTION_UP 结合输出结果，总结如下： 可以看出，当触发ACTION_DOWN的时候，事件的分发传递过程和1的时候一样，从Activity开始一层层向下传递，最终传递到最底层MyView，触发消费操作，然后MyView将消费操作移交上层处理，然后到达MyViewGroupB的onTouchEvent，并且进行了消费处理，事件处理到此不在向上移交。当触发ACTION_MOVE和ACTION_UP操作时，事件依然需要由Activity开始向下分发传递，但是当传递到MyViewGroupB后，由于其消费了ACTION_DOWN，事件将不再继续向下分发，而是直接由MyViewGroupB分发给自己的onTouchEvent进行继续处理。事件处理也不再向上移交。 4、将MyViewGroupB的onInterceptTouchEvent和onTouchEvent的返回值均改为true。这意味着既拦截，又消费。 输出结果如下： I/Activity: dispatchTouchEvent_ACTION_DOWN I/MyViewGroupA: dispatchTouchEvent_ACTION_DOWN I/MyViewGroupA: onInterceptTouchEvent_ACTION_DOWN I/MyViewGroupB: dispatchTouchEvent_ACTION_DOWN I/MyViewGroupB: onInterceptTouchEvent_ACTION_DOWN I/MyViewGroupB: onTouchEvent_ACTION_DOWN I/Activity: dispatchTouchEvent_ACTION_MOVE I/MyViewGroupA: dispatchTouchEvent_ACTION_MOVE I/MyViewGroupA: onInterceptTouchEvent_ACTION_MOVE I/MyViewGroupB: dispatchTouchEvent_ACTION_MOVE I/MyViewGroupB: onTouchEvent_ACTION_MOVE I/Activity: dispatchTouchEvent_ACTION_UP I/MyViewGroupA: dispatchTouchEvent_ACTION_UP I/MyViewGroupA: onInterceptTouchEvent_ACTION_UP I/MyViewGroupB: dispatchTouchEvent_ACTION_UP I/MyViewGroupB: onTouchEvent_ACTION_UP 结合输出结果，总结如下： 当触发ACTION_DOWN的时候，依然从Activity开始向下传递，当到达MyViewGroupB的是，因为在onInterceptTouchEvent进行了拦截操作，因此不再继续向下分发传递，而是交由MyViewGroupB的onTouchEvent进行处理消费。MyViewGroupB的onTouchEvent返回的是true，说明它决定对ACTION_DOWN进行处理，因此事件也就不再移交上层处理。当触发ACTION_MOVE和ACTION_UP的时候，事件还是从Activity开始向下传递，当到达MyViewGroupB的时候，由于之前进行了拦截操作，因此，MyViewGroupB直接将事件分发给自己的onTouchEvent进行处理，不在向下分发传递。事件处理也不再向上层移交。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://panxk.github.io/tags/Android/"}]},{"title":"基于eclipse进行ndk开发： JNI","slug":"JNI-CONFIG","date":"2018-11-20T06:25:34.000Z","updated":"2021-04-06T06:30:30.924Z","comments":true,"path":"2018/11/20/JNI-CONFIG/","link":"","permalink":"http://panxk.github.io/2018/11/20/JNI-CONFIG/","excerpt":"","text":"JNI 简介JNI是Java Native Interface的缩写，即Java本地调用。从Java1.1开始， JNI标准成为Java平台的一部分，它允许Java虚拟机（JVM）内部运行的 Java代码能够与用其它编程语言(如 C、C++ 和汇编语言)编写的应用程序 和库进行交互操作。 环境配置1 计算器 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量 新建-&gt; 变量名：ANDROID_SDK_HOME 变量值：D:\\ProgramFiles\\Android\\android-sdk-windows 2 Android 指定NDK的位置 打开eclipse，从菜单栏依次选择，Windows -&gt; Preferences -&gt; Android， 通过Browser选择ndk正确的路径，OK完成。 3 C/C++ 配置NDK目录 打开eclipse，从菜单栏依次选择，Windows -&gt; Preferences -&gt; C/C++ -&gt; build -&gt; Environment; Add New variable -&gt; Name : NDK_ROOT Value : D:\\ProgramFiles\\Android\\android-ndk-r10 4 配置eclipse 的 javaH 命令， 生成头文件工具 Run-&gt;External Tools-&gt;External Tools Configurations 左侧栏里选中Program，单击左上角的New launch configuration， 再单击Main选项卡，按照如下信息填写，需要确保Android sdk 路径下有类似android-19的文件夹，根据自己sdk实际情况调整。 NAME: Generate C and C++ Header File Location: $&#123;system_path:javah&#125; Working Directory: $&#123;project_loc&#125;/jni Arguments: -classpath &quot;$&#123;project_classpath&#125;; $&#123;env_var:ANDROID_SDK_HOME&#125;/platforms/android-19/android.jar&quot; $&#123;java_type_name&#125; ![](JNI-CONFIG/generate_c _and_c++_header_file.png) Eclipse 创建 Demo1 创建Android工程 File -&gt; NEW -&gt; Android Application Project -&gt; Next -&gt; Finish; 2 项目添加原生支持 所谓原生支持，就是本地支持，也就是native支持，也就是支持JAVA和C/C++混编。 Add Native Support demo工程(MyJniDemo) -&gt; 右键 -&gt; Android Tools -&gt; Add Native Support 执行完成后，将会在jni目录下生成 MyJniDemo.cpp Android.mk LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := MyJniDemo LOCAL_SRC_FILES := MyJniDemo.cpp include $(BUILD_SHARED_LIBRARY) 3 配置C/C++ Build 点击C/C++ Build -&gt; 选中Builder Settings -&gt; 配置 Build command : $&#123;NDK_ROOT&#125;/ndk-build.cmd 4 生成头文件 选中需要生成.h 头文件的java类，右键run -&gt; External Tools -&gt; Generate C and C++ Header File 编译成功后，会在jni文件夹下生成 对应包名 + 类名的.h 头文件 (eg: com_example_myjnidemo_MyJniActivity.h)","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://panxk.github.io/tags/Android/"}]},{"title":"cocos2dx","slug":"cocos2dx","date":"2018-09-16T06:47:37.000Z","updated":"2018-11-04T07:47:10.000Z","comments":true,"path":"2018/09/16/cocos2dx/","link":"","permalink":"http://panxk.github.io/2018/09/16/cocos2dx/","excerpt":"","text":"cocos2dx 2.2.6 + Eclipse 开发下载安装 Eclipse下载cocos2dx 2.2.6 解压到 D:\\cocos2dxcocos2dx2.2.6 解压路径：D:\\cocos2dx\\cocos2d-x-2.2.6 用Python创建自己的工程下载 [Python](https://www.python.org/downloads/release/python-2715/) Windows x86-64 MSI installer，安装过程忽略。 安装完Python之后，打开命令窗口(windows 命令窗口)， ``` bash $ python -v $ Python 2.7.15 ``` Create cocos2dx Demo ``` bash $ cd D:\\cocos2dx\\cocos2d-x-2.2.6\\tools\\project-creator $ D:\\cocos2dx\\cocos2d-x-2.2.6\\tools\\project-creator&gt;create_project.py -project MyTest -package com.sky.demo -language cpp ``` 工程就创建好了 路径：D:\\cocos2dx\\cocos2d-x-2.2.6\\projects Ecplise 编译 Demo 工程导入创建好的MyTest工程 打开Eclipse, File -&gt; Import -&gt; Android -&gt; Existing Android Code Into Workspace (不勾选 Copy project into workspace) -&gt; Root Directiory: D:\\cocos2dx\\cocos2d-x-2.2.6\\projects\\MyTest\\proj.android -&gt; Finish 导入cocos2dx lib (不勾选 Copy project into workspace) 打开Eclipse, File -&gt; Import -&gt; Android -&gt; Existing Android Code Into Workspace -&gt; Root Directiory: D:\\cocos2dx\\cocos2d-x-2.2.6\\cocos2dx\\platform\\android\\java -&gt; Finish 配置属性 MyTest MODEL 右键 Properties -&gt; Android -&gt; Add libcocos2dx -&gt; C/C++ Build -&gt; Builder Settings -&gt; Build command: D:\\ProgramFiles\\Android\\android-ndk-r10\\ndk-build.cmd jni -&gt; Application.mk -&gt; 添加 NDK_MODULE_PATH:= D:/cocos2dx/cocos2d-x-2.2.6;D:/cocos2dx/cocos2d-x-2.2.6/cocos2dx/platform/third_party/android/prebuilt cocos2d-x-3.17 + VS 2017 开发下载安装 VS 2017 、 Android Studio下载cocos2dx 3.1.7 解压到 D:\\cocos2dxcocos2dx3.1.7 解压路径：D:\\cocos2dx\\cocos2d-x-3.17 用Python创建自己的工程下载 [Python](https://www.python.org/downloads/release/python-2715/) Windows x86-64 MSI installer，安装过程忽略。 安装完Python之后，打开命令窗口(windows 命令窗口)， ``` bash $ python -v $ Python 2.7.15 ``` Create cocos2dx Demo ``` bash $ cd D:\\cocos2dx\\cocos2d-x-3.17\\tools\\cocos2d-console\\bin $ D:\\cocos2dx\\cocos2d-x-3.17\\tools\\cocos2d-console\\bin&gt; cocos new myTestGame -p com.cocos2dx.demo -d F:\\coco2dxwork -l cpp ``` 工程就创建好了 路径：F:\\coco2dxwork\\myTestGame Android Studio 编译 Demo 工程打开创建好的myTestGame工程 打开Android Studio, File -&gt; Open -&gt; F:\\coco2dxwork\\myTestGame\\proj.android VS2017 编译 Demo 工程打开创建好的myTestGame工程 打开Android Studio, File -&gt; Open -&gt; F:\\coco2dxwork\\myTestGame\\proj.win32","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://panxk.github.io/tags/Android/"}]},{"title":"win10 MongoDB安装配置启动","slug":"MongoDB","date":"2017-05-03T10:33:27.000Z","updated":"2018-11-19T11:27:12.000Z","comments":true,"path":"2017/05/03/MongoDB/","link":"","permalink":"http://panxk.github.io/2017/05/03/MongoDB/","excerpt":"","text":"环境配置安装下载[MongoDB](https://www.mongodb.com/) mongodb-win32-x86_64-2008plus-ssl-3.4.4-signed.msi。 双击安装，直接next，直到finish。 默认安装目录是C:\\Program Files\\MongoDB.我这里移动到D:\\MongoDB.之所以不选择Program Files文件夹是 因为中间有空格。后续的配置文件，路径不能有空格。 配置1 配置环境变量:D:\\MongoDB\\Server\\3.4\\bin 2 在D:\\MongoDB\\下新建data文件夹，进入data，新建db和logs文件 3 指定保存数据地址，在(以管理员身份运行)cmd中键入 mongod --dbpath D:\\MongoDB\\data\\db 4 前面是安装路径，后面是刚刚建立db文件夹的路径 5 在cmd中键入 mongod 6 等待出现waiting forconnection ，不要关闭当前cmd，在打开cmd，键入mongo(不要写成mongod) 之后有一个cmd会出现，connecting to :test，关闭两个cmd 7 打开cmd，键入 mkdir D:\\mongodb\\Data\\logs 关闭cmd 在D:\\MongoDB下建立一个mongod.cfg文件，在文件里面键入 systemLog: destination: file path: D:\\MongoDB\\data\\logs\\mong.log storage: dbPath: D:\\MongoDB\\data\\db 9 以管理员权限打开cmd，键入mongod --config &quot;D:\\mongodb\\mongod.cfg&quot; --install 之后去logs看，会出现一个新文件 连接调试cmd下键入 net start mongodb 开始连接 net stop mongodb 终止连接","categories":[],"tags":[]},{"title":"利用hexo搭建个人博客for windows","slug":"hexo","date":"2017-05-03T10:33:27.000Z","updated":"2021-04-06T01:34:35.905Z","comments":true,"path":"2017/05/03/hexo/","link":"","permalink":"http://panxk.github.io/2017/05/03/hexo/","excerpt":"","text":"环境配置安装 GIT下载Git，安装过程忽略。 安装 nvm（Node.js版本管理工具）nvm ，选择 nvm-setup.zip 下载 解压后，点击nvm-setup进行安装，可以选择默认路径，可以自定义路径。 我的默认路径（可自定义）： root: C:\\Users\\Administrator\\AppData\\Roaming\\nvm path: C:\\Program Files\\nodejs 安装完nvm之后，打开命令窗口(windows 命令窗口或者git bash 均可)， $ nvm -v $ 1.1.1 安装 Node.js继第2步之后， $ nvm install latest $ node -v $ v6.5.0 这是下载Node.js的最新版本，也可以指定某一版本。Node.js官网 Node.js安装完毕。在此过程中会将 npm 安装 安装 Hexo安装 Hexo ： $ npm install -g hexo-cli $ Hexo v 安装完成后可以查看版本信息 创建博客我是在D：盘新建 myblog 文件夹，进入myblog 执行 init $ hexo init [folder] 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。 new $ hexo new [layout] &lt;title> 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 generate $ hexo generate 生成静态文件。 server $ hexo server 启动服务器。默认情况下，访问网址为： http://localhost:4000/ 到此，本地就可以博客就可以访问了。 部署 github建立Repository 建立与你用户名对应仓库，仓库名必须是【your_user_name.github.io】,固定写法 建立关联 我的blog地址是 D:\\myblog ，在此文件夹下找到配置文件 _config.yml deploy: type: git repo: https://github.com/[yourname]/[yourname].github.io.git branch: master 将 yourname 替换成你的用户名 然后执行 $ npm install hexo-deployer-git --save 上传本地代码到github $ hexo deploy 浏览器中输入http://yourname.github.io/ , OK 了 参考：http://blog.csdn.net/tyro_java/article/details/51232458http://kaizige.vip/2016/06/10/how-to-build-up-yourself-hexo-blog/http://ibruce.info/2013/11/22/hexo-your-blog/?utm_source=tuicool&amp;utm_medium=referralaiohttp://www.jianshu.com/p/465830080ea9","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://panxk.github.io/tags/Hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-05-01T10:33:27.000Z","updated":"2021-04-02T08:02:03.532Z","comments":true,"path":"2017/05/01/hello-world/","link":"","permalink":"http://panxk.github.io/2017/05/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://panxk.github.io/tags/Android/"},{"name":"Hexo","slug":"Hexo","permalink":"http://panxk.github.io/tags/Hexo/"}]}